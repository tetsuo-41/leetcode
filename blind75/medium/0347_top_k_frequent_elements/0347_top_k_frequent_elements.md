# 🧩 問題名: [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

## 📝 問題概要

整数配列 `nums` と整数 `k` が与えられる。  
配列内で**最も頻出する k 個の要素**を返せ。  
出力の順序は問わない。

### 🔍 例

| Input | Output | 説明 |
|-------|---------|------|
| nums = [1,1,1,2,2,3], k = 2 | [1,2] | 1 は3回、2は2回出現 |
| nums = [1], k = 1 | [1] | 唯一の要素1 |
| nums = [1,2,1,2,1,2,3,1,3,2], k = 2 | [1,2] | 1と2が最も頻出 |

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア

この問題の本質は、「要素ごとの出現回数を数えて、上位 k 個を効率よく取り出す」こと。

#### 🧩 ステップ:
1. **頻度カウント:**  
   Python の `collections.Counter` を使って、各要素の出現回数を求める。  
   例: `nums = [1,1,2,2,3]` → `Counter({1: 2, 2: 2, 3: 1})`

2. **バケットソート（O(n) 解法）:**  
   - `freq[i]` に「出現回数が i の要素」を格納。  
   - 出現回数の高い順にバケットを逆順で走査し、上位 k 個を取得する。  
   - これにより、`O(n log n)` より速い `O(n)` を実現。

---

## 🧠 Why バケットソート？

`heapq`（ヒープ）を使う方法もあるが、  
ヒープでは挿入ごとに `O(log n)` がかかる。  
一方、バケットソートでは配列の添字を出現回数として直接アクセスでき、  
よりシンプルで高速。

---

## ⏱️ 計算量
- **時間計算量:** O(n)  
  （Counter作成O(n) + バケット走査O(n)）
- **空間計算量:** O(n)  
  （バケット配列と辞書の使用）

---

## 🧠 ポイントと学び
- 頻出要素を求める際、**ヒープよりもバケットソートがシンプルで速い**。
- Counterを使うと、要素カウントが一瞬でできる（`O(n)`）。
- 「ソートせずに上位k個を求める」→典型的なバケットテクニック。

---

## 📈 提出結果
- Runtime: **19ms** (Beats 20.33%)  
- Memory: **20.00MB** (Beats 5.96%)
