# 🌳 問題名: [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)

## 📝 問題概要

二分木の根ノード `root` が与えられる。  
木の各ノードを **レベル順（左から右へ、上から下へ）** に走査し、  
各レベルごとのノード値をリストとして返せ。

### 🔍 例

#### 例 1
Input: `root = [3,9,20,null,null,15,7]`  
Output: `[[3],[9,20],[15,7]]`

#### 例 2
Input: `root = [1]`  
Output: `[[1]]`

#### 例 3
Input: `root = []`  
Output: `[]`

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 木を **幅優先探索（Breadth-First Search, BFS）** で走査する。  
- `queue` にノードを入れ、**レベル単位で取り出していく**。
- 各レベルでキューに含まれるノード数を記録し、その分だけループして  
  `level` ごとのノード値をリスト化して結果に追加する。

---

### 🧩 アルゴリズム手順
1. `root` が `None` なら空リストを返す。
2. `queue` に `root` を入れて初期化。
3. `queue` が空になるまで次を繰り返す：
   - 現在のレベルのノード数（`len(queue)`）を取得。
   - その回数だけ `popleft()` でノードを取り出し、値を `level` に格納。
   - 左右の子ノードが存在すれば `queue` に追加。
   - 1レベル分の処理が終わったら `result.append(level)`。
4. 最後に `result` を返す。

---

### 🧠 BFS（幅優先探索）を使う理由
- **「レベルごと」** に処理する問題では BFS が最適。
- DFS（深さ優先探索）だと再帰で深く潜ってしまい、レベル単位の処理がしにくい。

---

## ⏱️ 計算量
- **時間計算量:** O(n)  
  各ノードを一度ずつ処理するだけ。
- **空間計算量:** O(n)  
  最悪の場合（完全二分木）ではキューに最大 n/2 ノードが入る。

---

## 🧠 ポイントと学び
- **BFS は「キュー」構造を使う**ことが定石。
- **各レベルのサイズを固定してループする**ことで、階層構造を明確に分けられる。
- 木構造問題では「再帰（DFS）」と「キュー（BFS）」を使い分けられるようになると強い。

---

## 📈 提出結果
- Runtime: 0ms (Beats 100.00%)
- Memory: 13.26MB (Beats 49.29%)

---