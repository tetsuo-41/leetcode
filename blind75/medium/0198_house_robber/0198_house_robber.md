# 🧩 問題名: [198. House Robber](https://leetcode.com/problems/house-robber/)

## 📝 問題概要

あなたは泥棒で、横並びの家を狙っている。  
ただし、**隣接する2軒の家を同じ夜に盗むと警報が鳴る**ため、隣同士は同時に盗めない。  

整数配列 `nums` が与えられ、`nums[i]` は i 番目の家にある金額を表す。  
盗める金額の **最大値** を返せ。

### 🔍 例
Input: nums = [1,2,3,1]  
Output: 4  
Explanation: 1 番目 (1) と 3 番目 (3) を盗む → 合計 4  

Input: nums = [2,7,9,3,1]  
Output: 12  
Explanation: 1 番目 (2) + 3 番目 (9) + 5 番目 (1) → 合計 12  

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア: 動的計画法（DP）
- `dp[i]` = i 番目までの家で盗める最大金額  
- 各家 `i` に対して選択肢は2つ:
  1. **盗まない** → `dp[i-1]`
  2. **盗む** → `dp[i-2] + nums[i]`
- よって、遷移式は:
dp[i] = max(dp[i-1], dp[i-2] + nums[i])


### 🧠 ベースケース
- `dp[0] = nums[0]`
- `dp[1] = max(nums[0], nums[1])`

### 🚀 最適化
- `dp[i]` を計算するのに必要なのは直前2つだけなので、**配列ではなく2変数で管理できる**。

---

## ⏱️ 計算量
- 時間計算量: O(n) （1回のループで完了）  
- 空間計算量: O(1) （2つの変数のみ使用）  

---

## 🧠 ポイントと学び
- 「**隣接要素が同時に選べない最大化問題**」＝DP の定番パターン。  
- `dp[i] = max(dp[i-1], dp[i-2] + nums[i])` は丸暗記しておく価値あり。  
- 配列全体を持たなくても直前2つだけあれば十分 → **空間最適化テク**。  
- 偶奇で選べばよいわけではなく、局所的に判断しなければならない

---

## 📈 提出結果
- Runtime: 0ms (Beats 100.00%)  
- Memory: 12.51MB (Beats 14.97%)  

---
