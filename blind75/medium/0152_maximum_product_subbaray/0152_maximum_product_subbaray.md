# 🧩 問題名: [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

## 📝 問題概要

整数配列 `nums` が与えられる。  
その中から**連続部分配列（subarray）**を選び、積（product）が最大となる値を返せ。  

### 🔍 例
Input: nums = [2,3,-2,4]  
Output: 6  
Explanation: 部分配列 [2,3] の積は 6 が最大。  

Input: nums = [-2,0,-1]  
Output: 0  
Explanation: [-2,-1] は積が 2 になるが、これは「連続部分配列」ではないため不可。  


## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 積の問題は「負の数」が絡むと符号が反転するため注意が必要。  
- ある位置 `i` までの「最大積」と「最小積」を同時に管理するのがポイント。  
  - なぜなら、負の数 × 最小積 が最大積に変わる可能性があるため。  
- 各ステップで以下を更新する：
  - `max_so_far = max(nums[i], nums[i] * prev_max, nums[i] * prev_min)`
  - `min_so_far = min(nums[i], nums[i] * prev_max, nums[i] * prev_min)`
- 全体の最大値を随時記録していく。

### 🧠 なぜ min も追跡するのか？
- 例: `[-2, 3, -4]`  
  - 途中で -2（負数）から始めると積が小さくなるが、次の負数 -4 を掛けることで **大きな正数 24** が得られる。  
- したがって、「最小積が最大に化ける」可能性があるため追跡必須。  

## ⏱️ 計算量
 • 時間計算量: O(n)  
 • 各要素を1回ずつ処理するだけ  
 • 空間計算量: O(1)  
 • 定数個の変数のみ使用  

## 🧠 ポイントと学び
 • 負数の影響を考慮して「最大」と「最小」を両方追跡するのがコツ。  
 • 累積和のような prefix-sum ではなく、動的に更新する DP 的アプローチ。  
 • 「負数 × 負数 ＝ 正数」がカギ。  

## 📈 提出結果
 • Runtime: 10ms (Beats 61.45%)  
 • Memory: 13.15MB (Beats 53.16%)  

---
