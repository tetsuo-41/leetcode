# 🧩 問題名: [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

## 📝 問題概要
二分木の根 `root` が与えられる。この木が **有効な二分探索木（BST）かどうか** を判定せよ。

BST の条件は以下の通り：
1. 各ノードの左部分木は、ノードの値より**小さい値のみ**を持つ
2. 各ノードの右部分木は、ノードの値より**大きい値のみ**を持つ
3. 左右部分木もそれぞれ BST であること

---

### 🔍 例
**例1**  
Input: root = [2,1,3]  
Output: true  

**例2**  
Input: root = [5,1,4,null,null,3,6]  
Output: false  

---

## ✅ 解法方針（Approach）
### 💡 コアアイデア
- BST 判定は **各ノードが「有効範囲」に収まるか」** を再帰的に確認する
- 左部分木は `(min_val, node.val)` の範囲、右部分木は `(node.val, max_val)` の範囲を更新
- ノードが範囲外なら False、末端(None)に到達したら True

---

### 🧠 なぜ範囲チェックが必要か
単純な「左 < node.val < 右」だけだと、祖先ノードとの関係を見落とす場合がある  
例: `[10,5,15,null,null,6,20]`  
- 15 の左子 6 は 15 より小さいが、10 より小さい → BST 条件に違反  
- 範囲チェックをすると、`6 < 10` で False を返せる

---

## ⏱️ 計算量
- 時間計算量: O(n)  
- 空間計算量: O(h)（再帰スタック、h は木の高さ）

---

## 🧠 ポイントと学び
- 「左 < node < 右」の単純比較では不十分
- 範囲を更新して再帰的にチェックするパターンが定石
- BSTを中順で処理すると昇順になることを用いても解けるが、全ノードを走査するため、途中で早期終了はできない。時間計算量はO(n)で変わらないが、空間計算量はO(n)になってしまう。

---

## 📈 提出結果
- Runtime: 3ms (Beats 69.99%)  
- Memory: 17.16MB (Beats 56.00%)  

---