# 🧩 問題名: [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)

## 📝 問題概要

二分木の根ノード `root` が与えられる。  
**左右の子ノードをすべて反転（スワップ）** した二分木を返せ。

---

### 🔍 例

**Example 1**
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
変換イメージ:
4    4
/ \ /
2 7 → 7 2
/ \ / \ / \ /
1 3 6 9 9 6 3 1

**Example 2**
Input: root = [2,1,3]
Output: [2,3,1]

**Example 3**
Input: root = []
Output: []

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア

左右の子ノードを**すべて入れ替える**ことが目的。  
各ノードで次の処理を行う：

1. 左右の子ノードをスワップする  
2. 再帰的に左右の子ノードにも同じ処理を適用する  

再帰（DFS）を使うことで、  
**葉から順に反転処理が伝播していく**イメージになる。

---

### 🧠 別解：BFS（キュー）でも可能

再帰ではなく、キューを使ってレベル順に各ノードの左右をスワップしてもOK。  
ただし問題の規模が小さいため、再帰解法の方がシンプルで読みやすい。

---

## ⏱️ 計算量

- **時間計算量:** O(n)  
  各ノードを1回ずつ訪問してスワップするだけ。
- **空間計算量:** O(h)（再帰スタック）  
  h は木の高さ。最悪の場合 O(n)。

---

## 🧠 ポイントと学び

- 再帰関数の基本構造を理解するのに最適な問題。  
- 「根での処理 → 再帰呼び出し」という形でツリー全体を操作できる。
- 対称性を確認する際などにも応用できる。

---

## 📈 提出結果
- Runtime: 0ms (Beats 100.00%)  
- Memory: 12.59MB (Beats 30.85%)

---
