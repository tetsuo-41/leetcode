# 🧩 問題名: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

## 📝 問題概要

与えられた区間（intervals）の配列において、重なり合う区間をすべてマージ（結合）し、重複のない区間リストを返せ。  

区間 `intervals[i] = [starti, endi]` は閉区間（starti から endi を含む）として扱う。  

### 🔍 例
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]  
Output: [[1,6],[8,10],[15,18]]  
Explanation: [1,3] と [2,6] が重なっているので [1,6] に結合される。

Input: intervals = [[1,4],[4,5]]  
Output: [[1,5]]  
Explanation: [1,4] と [4,5] は端点で重なるので [1,5] に結合される。

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
1. 区間を **開始時刻でソート** する。  
   → 区間を順番に処理することで、重なりの有無を前の区間だけと比較すればよくなる。  

2. 新しいリスト `merged` を用意し、先頭の区間を入れてから順に処理。  

3. 各区間 `cur` と `merged[-1]`（最後に入れた区間）を比較:
   - **重なる場合**:  
     `merged[-1][1] = max(merged[-1][1], cur[1])` として結合する。  
   - **重ならない場合**:  
     そのまま新しい区間として `merged` に追加する。  

---

## ⏱️ 計算量
- **時間計算量**: O(n log n)  
  ソートが支配的。各区間は高々 1 回しか処理されない。
- **空間計算量**: O(n)  
  マージ結果を格納するリストが必要。

---

## 🧠 ポイントと学び
- 区間系の問題では **ソートして貪欲法的に処理**するのが定石。  
- 重なり判定は `current.start <= prev.end` で行う。  
- マージ処理は端点で接している場合（例: [1,4], [4,5]）も重なりとみなす。  

---

## 📈 提出結果
- Runtime: 7ms (Beats 96.13%)  
- Memory: 16.04MB (Beats 67.31%)  

---
