# 🧩 問題名: [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)

## 📝 問題概要

与えられた**区間の配列 intervals** に対して、  
重なり（オーバーラップ）をなくすために**削除すべき最小の区間数**を求めよ。  

> 注意: 区間が端点で接しているだけの場合は重なりとはみなさない。  
> 例: [1,2] と [2,3] は重なっていない。

---

### 🔍 例
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]  
Output: 1  
Explanation: [1,3] を削除すれば残りは重ならない  

Input: intervals = [[1,2],[1,2],[1,2]]  
Output: 2  
Explanation: 2つの [1,2] を削除して残りを非重複に  

Input: intervals = [[1,2],[2,3]]  
Output: 0  
Explanation: 既に重なっていないので削除不要

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- **終了時間（end）でソート**し、なるべく早く終わる区間を優先して残す。
- 前の区間の終了時刻 `prev_end` を追跡。
- 新しい区間が `prev_end` より開始時刻が小さい場合 → **重なっているので削除カウントを増やす**
- それ以外の場合 → `prev_end` を更新して次に進む
- 結果的に **最小の削除数** = 総区間数 - 選んだ非重複区間数

### 🧠 Why 終了時刻でソート？
→ 早く終わる区間を優先することで、次の区間と重なる可能性を最小化できる。  
これは「**グリーディ法（貪欲法）の典型例**」で、最大非重複区間集合問題に対応する。

---

## ⏱️ 計算量
- 時間計算量: O(n log n) （ソート部分が支配的）
- 空間計算量: O(1)（ソート以外の追加メモリほぼ不要）

---

## 🧠 ポイントと学び
- 「最小削除数」を求める場合は、最大非重複区間を選ぶアプローチに置き換えると分かりやすい。
- 終了時間でソートするグリーディ法は、区間スケジューリング問題での定石テクニック。
- 重なり判定は「開始 < 前の終了」で十分（端点が接する場合は重なりなし）。
- 最終的に重なりをなくすだけですべての区間を網羅しないといけないわけではない

---

## 📈 提出結果
- Runtime: 179ms (Beats 37.69%)
- Memory: 45.22MB (Beats 53.96%)

---