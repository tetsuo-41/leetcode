# 🧩 問題名: [39. Combination Sum](https://leetcode.com/problems/combination-sum/)

## 📝 問題概要

整数配列 `candidates`（要素はすべて異なる）と整数 `target` が与えられる。  
`candidates` の要素を何度でも使ってよいので、**要素の和がちょうど target になる組み合わせ**をすべて求めよ。  
解は重複しない組み合わせのリストとして返すこと。順序は問わない。

### 🔍 例
Input: candidates = [2,3,6,7], target = 7  
Output: [[2,2,3],[7]]  
Explanation: 2 + 2 + 3 = 7, 7 = 7

Input: candidates = [2,3,5], target = 8  
Output: [[2,2,2,2],[2,3,3],[3,5]]

Input: candidates = [2], target = 1  
Output: []  

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- **DFS（深さ優先探索） + Backtracking** を用いる。
- 各候補 `num` を「使う / 使わない」の分岐で探索する。
- 「使う」場合は target から `num` を引き、残りを再帰的に解く。
- target が **0 になれば有効な組み合わせ**として結果に追加。
- target が負になれば打ち切る（pruning）。
- 同じ要素を複数回使うために、探索再帰で「現在の位置 index」からスタートするようにする。

### 🧠 ポイント
- **順序を区別しない**ため、DFSの開始位置を制御する（`start` 引数を持たせる）。  
  例: [2,3,2] と [2,2,3] を同じものとして扱う。
- target が 0 になる瞬間をキャッチ → 解追加。

---

## ⏱️ 計算量
- 時間計算量: O(N^(T/M))  
  - N = 候補の数  
  - T = target  
  - M = 最小の候補値  
  → 最悪の場合、最小の数だけで target を埋めるので深さは T/M になる。
- 空間計算量: O(T/M)（再帰スタック + 一時的な組み合わせ）

---

## 🧠 ポイントと学び
- **組み合わせ探索系は backtracking の代表例**。
- 「使う/使わない」の分岐を再帰で作り、条件を満たしたら追加するのが基本パターン。
- 重複を防ぐために「インデックス制御」が超重要。

---

## 📈 提出結果（例）
- Runtime: 7ms (Beats 95.58%)  
- Memory: 12.50MB (Beats 52.31%)  

