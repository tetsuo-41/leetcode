# 🧩 問題名: [91. Decode Ways](https://leetcode.com/problems/decode-ways/)

## 📝 問題概要

数字で表された暗号文 `s` が与えられる。  
次の対応表に基づき、考えられる**全ての復号パターンの数**を求めよ。

| 数字 | 文字 |
|------|------|
| 1 | A |
| 2 | B |
| ... | ... |
| 26 | Z |

### ⚠️ 制約と注意点
- "0" は単独では無効（例: `"06"` は無効）。  
- `"10"` や `"20"` は有効（"J"・"T"）。  
- 各桁または2桁ずつ見ながら、**有効な組み合わせのみ**カウントする必要がある。  

---

### 🔍 例

| 入力 | 出力 | 説明 |
|------|------|------|
| s = "12" | 2 | "AB"(1 2) または "L"(12) |
| s = "226" | 3 | "BZ"(2 26), "VF"(22 6), "BBF"(2 2 6) |
| s = "06" | 0 | "06" は無効なコード |

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア：動的計画法（DP）
文字列 `s` の i 文字目までに「何通りの復号方法があるか」を  
`dp[i]` に格納する。

#### 状態遷移の考え方：
1. **1桁の数字（s[i-1]）** が `'1'`～`'9'` の場合：  
   → `dp[i] += dp[i-1]`  
   （この1桁を単独で文字に変換できる）

2. **2桁の数字（s[i-2:i]）** が `'10'`～`'26'` の場合：  
   → `dp[i] += dp[i-2]`  
   （この2桁を1文字に変換できる）

#### 初期条件：
- `dp[0] = 1`（空文字は1通りとみなす）
- `dp[1] = 1` ただし、最初の文字が `'0'` なら `0`  

---

### 🧩 実装イメージ
たとえば `s = "226"` の場合：

| i | s[:i] | dp[i] | 理由 |
|--|--------|--------|------|
| 0 | "" | 1 | 初期値 |
| 1 | "2" | 1 | '2' は有効 |
| 2 | "22" | 2 | "2" + "2", "22" |
| 3 | "226" | 3 | "2 2 6", "22 6", "2 26" |

---

## ⏱️ 計算量
- **時間計算量:** O(n)  
  各文字に対して定数回の計算のみ行う  
- **空間計算量:** O(n)（dp配列を使用）

> ※ 最適化すれば O(1) にもできる（dp[i-1], dp[i-2] のみ保持）

---

## 🧠 ポイントと学び
- `"0"` の扱いが最も重要（単独では無効）。  
- dp[i] は「i文字目までの部分問題の解」を表す定番構造。  
- 「1桁」「2桁」両方を条件で分けて足すのがコツ。

---

## 📈 提出結果
- Runtime: 4ms (Beats 27.67%)  
- Memory: 12.52MB (Beats 28.38%)

---
