# 🧩 問題名: [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)

## 📝 問題概要

m x n の 2D バイナリグリッド `grid` が与えられる。  
`'1'` は陸地、`'0'` は水を表す。  

**陸地が水で囲まれた島の数**を返せ。  
島は**隣接する陸地（上下左右のみ）**で形成される。  
グリッドの四辺はすべて水に囲まれていると仮定してよい。

---

### 🔍 例
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]  
Output: 1  
Explanation: 1つの島のみ存在

Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]  
Output: 3  
Explanation: 3つの島が存在

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 島の数を数えるには、**DFS または BFS で連結した '1' をまとめて訪問済みにする**方法が定石。
- ある陸地セルを見つけたら、DFS/BFS で隣接するすべての陸地を `'0'` に変える（または visited に記録）。
- こうすることで、同じ島を二度数えないようにする。
- グリッド全体を走査し、未訪問の陸地セルに遭遇するたびに島カウントを +1。

---

### 💡 実装例（DFS）
- 再帰 DFS で上下左右を探索
- 訪問済みのセルは `'0'` に変える

---

## ⏱️ 計算量
- 時間計算量: O(m * n)
グリッドの全セルを一度ずつ訪問
- 空間計算量: O(m * n)（最悪再帰呼び出しスタックの場合）

---

## 🧠 ポイントと学び
- DFS/BFS で「連結成分」を探索するときは、訪問済みマークを必ず付けること。
- 2D グリッドでの探索パターンは、上下左右の方向ベクトルで簡潔に書ける。
- 再帰 DFS は書きやすいが、深さが深くなる場合はスタック/キューを使った BFS のほうが安全。(Python のデフォルト再帰深度は約 1000 なので、それを超えると スタックオーバーフロー、RecursionError: maximum recursion depth exceeded となる。)

---

## 📈 提出結果
- Runtime: 221ms (Beats 71.74%)  
- Memory: 27.94MB (Beats 50.92%)  

---