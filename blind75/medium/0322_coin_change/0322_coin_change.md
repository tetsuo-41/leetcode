# 🧩 問題名: [322. Coin Change](https://leetcode.com/problems/coin-change/)

## 📝 問題概要

コインの種類を表す配列 `coins` と、支払うべき金額 `amount` が与えられる。  
無限に使えるコインからいくつか選び、ちょうど `amount` を作るときの**最小のコイン枚数**を求めよ。  
もし作れない場合は `-1` を返す。  

### 🔍 例
Input: coins = [1,2,5], amount = 11  
Output: 3  
Explanation: 11 = 5 + 5 + 1  

Input: coins = [2], amount = 3  
Output: -1  

Input: coins = [1], amount = 0  
Output: 0  

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
これは典型的な **動的計画法（DP）** の問題。  
- `dp[x]` を「金額 x を作るのに必要な最小コイン数」と定義する。  
- 初期化: `dp[0] = 0`（金額0を作るにはコイン0枚）。  
- 遷移:  
  各コイン `c` に対して  
if x - c >= 0:
dp[x] = min(dp[x], dp[x - c] + 1)
と更新していく。  
- 最終的に `dp[amount]` が答え。ただし未更新のままなら `-1` を返す。

### 🧠 ポイント
- **無限に使える**＝ナップサック問題の「完全ナップサック型」。
- DPテーブルを `amount + 1` で用意して「最小化問題」を解く。
- 1枚でも作れない金額を区別するために、初期値は `inf` に設定する。

---

## ⏱️ 計算量
- 時間計算量: **O(n × amount)**  
（n = コインの種類数）
- 空間計算量: **O(amount)**  
（1次元 DP 配列を使用）

---

## 🧠 ポイントと学び
- 金額ごとに「最小枚数」を積み上げる DP は「コイン問題」の王道。  
- **最小化 or 最大化**を問う DP では、`inf` / `-inf` 初期化が定番。  
- 「使える回数が無制限」＝**完全ナップサック型**と覚えると応用が効く。

---

## 📈 提出結果
- Runtime: 854ms (Beats 53.54%)  
- Memory: 13.10MB (Beats 34.33%)  
