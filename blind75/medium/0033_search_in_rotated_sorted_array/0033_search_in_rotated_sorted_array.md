# 🧩 問題名: [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

## 📝 問題概要

整数の配列 `nums` が与えられる。  
配列は昇順でソートされているが、**ある未知の位置で回転（rotated）**されている可能性がある。  
この配列に対して、整数 `target` が存在すればその**インデックス**を返し、存在しなければ `-1` を返せ。  

アルゴリズムは **O(log n)** の計算量である必要がある。

### 🔍 例
Input: nums = [4,5,6,7,0,1,2], target = 0  
Output: 4  

Input: nums = [4,5,6,7,0,1,2], target = 3  
Output: -1  

Input: nums = [1], target = 0  
Output: -1  

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 配列は「ソート済み」だが「回転」されているため、普通の二分探索をそのまま使えない。
- しかし、どの時点でも **必ず片方の部分配列はソートされている** という性質を利用できる。
  1. `nums[mid]` と `nums[left]` を比較して、**左半分がソートされているか**を確認。
  2. もし `target` がその範囲に入っていれば左側を探索、そうでなければ右側を探索。
  3. 逆に右半分がソートされている場合も同様に処理。
- これにより、回転されていても O(log n) で探索可能。

---

## ⏱️ 計算量
- 時間計算量: O(log n)  
  （二分探索で探索範囲を半分に絞っていくため）
- 空間計算量: O(1)  
  （追加の配列などは不要）

---

## 🧠 ポイントと学び
- **回転ソート配列**は「どちらか一方は必ずソートされている」という性質がカギ。  
- 普通の二分探索では「単調増加」を前提にしているが、回転配列でも条件分岐を加えれば応用できる。  
- **O(log n) 要求＝二分探索系アプローチ**と結びつけるのが定石。

---

## 📈 提出結果（例）
- Runtime: 0ms (Beats 100.00%)  
- Memory: 12.68MB (Beats 42.95%)
