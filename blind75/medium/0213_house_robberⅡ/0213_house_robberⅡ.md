# 🧩 問題名: [213. House Robber II](https://leetcode.com/problems/house-robber-ii/)

## 📝 問題概要

泥棒が円形に並んだ家を襲おうとしている。  
各家には `nums[i]` の金額があり、**隣接する家を同じ夜に襲うと警報が鳴る**。  
家は円形に並んでいるため、**最初の家と最後の家も隣同士**になる。

泥棒が警報を鳴らさずに盗める**最大金額**を求めよ。

---

### 🔍 例

| Input | Output | Explanation |
|-------|---------|-------------|
| nums = [2,3,2] | 3 | 1番目と3番目は隣同士なので同時に盗めない。2番目の家（3）だけ盗むのが最適。 |
| nums = [1,2,3,1] | 4 | 1番目と3番目の家を盗むと合計4。 |
| nums = [1,2,3] | 3 | 2番目または3番目を盗むのが最適。 |

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア

この問題は **「House Robber I」**（線形の場合）の拡張。  
ただし、家が円形になっているため、  
**最初と最後を同時に盗むことができない**という制約が追加されている。

したがって、以下の2パターンに分けて考える：

1. **最初の家を含める場合** → 最後の家は盗めない  
   → `nums[:-1]`（最後を除く部分列）で通常の House Robber を解く  
2. **最後の家を含める場合** → 最初の家は盗めない  
   → `nums[1:]`（最初を除く部分列）で通常の House Robber を解く  

両方を計算し、その**最大値**を答えとする。

---

### 🧩 通常版 House Robber のDP式

`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`

- `dp[i-1]`: 現在の家を盗まない  
- `dp[i-2] + nums[i]`: 現在の家を盗む  
- 計算量は O(n)、空間は O(1) に圧縮可能。

---

### 🧠 実装ポイント

- 円形を考慮するため、要素数1の場合を特別処理（`return nums[0]`）。
- 2パターンの線形計算を `max()` で比較。

---

## ⏱️ 計算量

- **時間計算量**: O(n)  
  2回の線形DPを行うだけ。
- **空間計算量**: O(1)  
  DP配列を変数2つで代用可能。

---

## 🧠 ポイントと学び

- 円環構造を扱うときは、**分割して線形に直す**のが定石。
- DPは「盗む or 盗まない」の2択を重ねる問題に強い。
- House Robber I を完全に理解していれば自然に拡張できる。

---

## 📈 提出結果（想定）
- Runtime: 0 ms (Beats 100.00%)  
- Memory: 12.50 MB (Beats 16.01%)

---