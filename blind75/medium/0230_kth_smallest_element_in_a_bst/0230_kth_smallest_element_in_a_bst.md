# 🧩 問題名: [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

## 📝 問題概要

二分探索木（BST）の根ノード `root` と整数 `k` が与えられる。  
BST の全ノードの値の中で、**k 番目に小さい値**を返せ。

BST（Binary Search Tree）の性質：
- 左部分木の値 < 根ノードの値 < 右部分木の値  
この性質を利用して、「中順（inorder）走査」を行えば、**昇順にノードを取得できる**。

---

### 🔍 例

**Example 1**
Input: root = [3,1,4,null,2], k = 1
Output: 1
BST の昇順順序は [1, 2, 3, 4] → 1 番目に小さいのは 1。

**Example 2**
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
BST の昇順順序は [1, 2, 3, 4, 5, 6] → 3 番目に小さいのは 3。

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- **BST の中順（inorder）走査**を行うと、ノード値が **小さい順（昇順）** に並ぶ。
- したがって、inorder で k 回目に訪れるノードの値が **k 番目に小さい要素**。
- 走査には以下の2通りがある：
  1. 再帰的に inorder traversal
  2. **スタックを使った反復的（iterative）inorder traversal**

ここでは後者（iterative）で実装。  
再帰よりもメモリ効率がよく、LeetCode でもよく使われる。

---

### 🧩 アルゴリズム手順
1. 空のスタックを用意。
2. 現在ノード `root` からスタート。
3. 左の子ノードをすべてスタックに積み上げる。
4. 左の尽きたところで、スタックの一番上を pop（これが次に小さいノード）。
5. これを `k` 回繰り返す。  
   → pop した回数が `k` に達したとき、そのノードの値を返す。

---

### 🧠 例での動作イメージ
Input: root = [3,1,4,null,2], k = 1
中順: 1 → 2 → 3 → 4
最初に pop されたノード = 1 → k=1 のとき答えは 1

---

## ⏱️ 計算量
- **時間計算量:** O(H + k)  
  H = 木の高さ。最悪の場合（片側に伸びた木）は O(n)。
  k 番目まで探索するため、最悪 O(n)。
- **空間計算量:** O(H)（スタック使用分）

---

## 🧠 ポイントと学び
- BST の中順走査は **昇順順序**になるという基本原理を活用。
- 再帰より iterative の方が汎用性が高く、Stack を用いたパターンを習得すべき。
- Follow-up の「頻繁な挿入/削除がある場合」は、ノードごとに**部分木のノード数をキャッシュ**しておき、順位探索を O(log n) で行う方法が考えられる（Order Statistics Tree）。
- 今回のstackは戻るためのnodeの順番を保持するためのもので、昇順にしたものを保持するものではない

---

## 📈 提出結果
- Runtime: **0ms** (Beats **100.00%**)  
- Memory: **20.32MB** (Beats **24.81%**)

---
