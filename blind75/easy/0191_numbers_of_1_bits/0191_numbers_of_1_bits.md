# 🧩 問題名: [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)

## 📝 問題概要

正の整数 `n` が与えられる。  
その **2進数表現における 1 のビットの数（Hamming weight）** を返す関数を作成せよ。

### 🔍 例

Input: n = 11  
Output: 3  
Explanation: 11 の 2進数表現は 1011 で、1 が 3つある。

Input: n = 128  
Output: 1  
Explanation: 128 の 2進数表現は 10000000 で、1 が 1つだけ。

Input: n = 2147483645  
Output: 30  
Explanation: 2147483645 の 2進数表現は 1111111111111111111111111111101 で、1 が 30個ある。

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 2進数の各ビットを調べて、1 の個数をカウントする。
- Python では組み込み関数 `bin()` が便利：
  - `bin(n)` は `"0b1011"` のように文字列で返す。
  - 文字列の `'1'` をカウントするだけで Hamming weight が求まる。
- さらにビット演算で直接計算することも可能：
  - `n & (n-1)` は **最下位の 1 ビットを消す操作**。
  - これを 0 になるまで繰り返してカウントすると効率的。

### 🧠 Why n & (n-1)？
- この操作で毎回 1 を 1つずつ消せるため、ループ回数は 1 の数だけ。
- 大きな整数でも余計なループを避けられるので高速。

## ⏱️ 計算量
- 時間計算量: O(1) または O(k) （k は 32ビット中の 1 の個数）  
- 空間計算量: O(1)  

---

## 🧠 ポイントと学び
- Python では文字列操作で簡単に求められる。
- ビット演算のテクニックは、面接でよく出る「高速な 1 のカウント」方法。
- `n & (n-1)` の操作は覚えておくと便利。

## 📈 提出結果
- Runtime: 0ms (Beats 100.00%)  
- Memory: 12.52MB (Beats 9.27%)  
