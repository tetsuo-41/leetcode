# 🧩 問題名: [338. Counting Bits](https://leetcode.com/problems/counting-bits/)

---

## 📝 問題概要

整数 n が与えられる。  
0 から n までの各整数 i に対して、**i の二進数表現に含まれる 1 の個数**を格納した配列 ans を返せ。  

---

### 🔍 例
Input: n = 2  
Output: [0,1,1]  
Explanation:  
0 → 0  
1 → 1  
2 → 10  

Input: n = 5  
Output: [0,1,1,2,1,2]  
Explanation:  
0 → 0  
1 → 1  
2 → 10  
3 → 11  
4 → 100  
5 → 101  

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 各整数 i に対して、i の二進数に含まれる 1 の個数を求める。  
- Python では `bin(i).count('1')` が便利で、i を二進数文字列に変換して 1 の個数を数えることができる。
- これを 0 から n までループして配列に格納するだけ。

---

### 🧠 効率化（DP的アプローチ）
- 各 i の 1 の個数は `i >> 1` の 1 の個数に依存する。  
- 式: `countBits[i] = countBits[i >> 1] + (i & 1)`  
  - i >> 1 は i を右に 1 ビットシフト（つまり i // 2）  
  - i & 1 は i の最下位ビットが 1 かどうか  

これにより O(n) 時間で求められる。

---

## ⏱️ 計算量
- 時間計算量: O(n)  
  - 0 から n までの各整数を一度ずつ処理  
- 空間計算量: O(n)  
  - 結果配列 ans を格納

---

## 🧠 ポイントと学び
- 「右に1ビットシフトして i//2 の結果を使う」ことで、すでに計算した値を再利用できる。
- 二進数表現の 1 の個数は、ビット演算を使うと効率よく求められる。  
- 「i の 1 の個数は i//2 の 1 の個数 + i の最下位ビット」と覚えておくと便利。
- 繰り返しの bin(i).count('1') よりも高速でメモリ効率も良い。

---

### 📈 提出結果
- Runtime: 3ms (Beats 99.39%)  
- Memory: 17.83MB (Beats 48.54%)  

---