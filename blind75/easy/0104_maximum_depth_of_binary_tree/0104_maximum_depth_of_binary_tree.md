# 🧩 問題名: [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

## 📝 問題概要

二分木の根ノード `root` が与えられる。  
**根から最も深い葉ノードまでの最長経路に含まれるノードの数（深さ）** を返す問題。

### 🔍 例

#### 例1
Input: root = [3,9,20,null,null,15,7]  
Output: 3  
Explanation:  
最も深い経路は `3 → 20 → 15` または `3 → 20 → 7` で、ノード数は 3。

#### 例2
Input: root = [1,null,2]  
Output: 2

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
「木の深さ」を求める典型問題。  
根から左右の部分木をそれぞれ探索し、**深い方の深さ + 1（根の分）** を返せばよい。

### 🧩 再帰（DFS）アプローチ
1. **ベースケース**:  
   `root` が `None`（空の木）の場合、深さは 0。
2. **再帰ステップ**:  
   左右の部分木の最大深さをそれぞれ求める。
3. **結果の合成**:  
   `1 + max(左部分木の深さ, 右部分木の深さ)` を返す。

### 🧠 直感的な理解
各ノードで「自分の深さ = 1 + 子の最大深さ」と考えると、  
最も深い葉ノードまで自然に探索される。

---

## 🧮 例でのイメージ

  3
 / \
9  20
   / \
  15  7

- 9の深さ → 1  
- 15と7の深さ → 1  
- 20の深さ → 1 + max(1,1) = 2  
- 根3の深さ → 1 + max(1,2) = 3 ✅

---

## ⏱️ 計算量

- **時間計算量:** O(n)  
  （全ノードを一度ずつ訪問する）
- **空間計算量:** O(h)  
  （再帰のコールスタック分。最悪 O(n)、平均 O(log n)）

---

## 🧠 ポイントと学び

- 二分木の問題では「帰りがけ（後順）」に値を計算するのが定石。  
  → 再帰で部分木を処理し、戻り値で深さを伝える。
- 「空の場合の0」「根＋max(左, 右)」というパターンは他の木問題でも頻出。

---

## 📈 提出結果
- Runtime: 2ms (Beats 67.99%)  
- Memory: 15.04MB (Beats 66.88%)

---