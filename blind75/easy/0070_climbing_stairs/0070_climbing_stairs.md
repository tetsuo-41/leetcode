# 🧩 問題名: [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)

## 📝 問題概要

階段を登るのに **n 段** 必要である。  
1回で **1段** または **2段** 登れるとすると、**頂上にたどり着く異なる方法の数**を求めよ。  

### 🔍 例
Input: n = 2  
Output: 2  
Explanation:  
1. 1 + 1  
2. 2  

Input: n = 3  
Output: 3  
Explanation:  
1. 1 + 1 + 1  
2. 1 + 2  
3. 2 + 1  

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- この問題は **フィボナッチ数列**と同じ構造を持つ。  
- 頂上に到達する方法は次のように分解できる:
  - 最後の一歩を「1段」で登った場合 → `n-1` 段までの方法数  
  - 最後の一歩を「2段」で登った場合 → `n-2` 段までの方法数  
- よって漸化式は:
f(n) = f(n-1) + f(n-2)
- 初期条件:
- f(1) = 1 （1段のときは「1」のみ）  
- f(2) = 2 （「1+1」と「2」の2通り）

### 🧑‍💻 実装のポイント
- 単純な再帰は指数時間になるため非効率。  
- **動的計画法 (DP)** または **変数2つでの繰り返し更新**で O(n) 時間・O(1) 空間で解ける。

## ⏱️ 計算量
- 時間計算量: O(n)  
- 空間計算量: O(1)（2変数で十分）

## 🧠 ポイントと学び
- フィボナッチ数列に帰着できる典型問題。  
- 「最後の一歩をどう踏むか」で再帰関係を考えるのは動的計画法の基本パターン。  
- メモリ削減のため、DP配列を使わず2変数で管理できるのも重要なテクニック。
- 数式解法（Binetの公式）は理論的には O(1) で美しいが、誤差の可能性あり。

## 📈 提出結果
- Runtime: 0ms (Beats 100.00%)  
- Memory: 12.30MB (Beats 98.77%)  
