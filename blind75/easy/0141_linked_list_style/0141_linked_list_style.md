# 🧩 問題名: [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

## 📝 問題概要

与えられた単方向リンクリスト `head` が**サイクル（cycle）を持つかどうか**を判定せよ。

サイクルとは、あるノードが次のノードを辿っていくことで**再び同じノードに戻ってくるループ**が存在する状態を指す。

※ 入力として `pos` は与えられないが、内部的には tail が pos 番目のノードに接続されていることを意味する。

### 🔍 例

Input: head = [3,2,0,-4], pos = 1  
Output: true  
Explanation: 最後のノード -4 が index 1 のノード（値 2）に接続されており、ループが形成されている。

Input: head = [1,2], pos = 0  
Output: true  
Explanation: 2 → 1 → 2 ... のようにループ。

Input: head = [1], pos = -1  
Output: false  
Explanation: 単一ノードであり、次が None なのでループは存在しない。

## ✅ 解法方針（Approach）

### 💡 コアアイデア

- **「2ポインタ法（Floyd's Cycle Detection Algorithm）」**を使う。
- `slow` ポインタは1ステップ、`fast` ポインタは2ステップずつ進める。
- サイクルが存在すれば、必ずどこかで `slow == fast` になる。
- 存在しなければ、`fast` は `None` に到達して終了。

### 🧠 なぜ2ポインタで検出できるのか？

ループ内では `fast` が `slow` を追い抜き続けるため、**必ず同じノードにぶつかる瞬間がくる**。  
これは「円形トラックで速い人が遅い人に追いつく」イメージ。

## ⏱️ 計算量

- 時間計算量: **O(n)**  
  → 各ノードを最大2回しか訪れない（fastとslow）
- 空間計算量: **O(1)**  
  → 追加メモリを使用しない。

## 🧠 ポイントと学び

- サイクル検出では**Floydのアルゴリズム（2ポインタ法）**が定番。
- `set()` に訪問ノードを格納して検出も可能だが、空間計算量が O(n) になる。
- **O(1)の空間で解くことが求められる場合は2ポインタ法一択**。

## 📈 提出結果

- Runtime: 37ms (Beats 57.74%)
- Memory: 19.46MB (Beats 85.30%)

