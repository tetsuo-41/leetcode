# 🧩 問題名: [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)

## 📝 問題概要

32ビットの符号なし整数 **n** が与えられる。  
この整数の **ビットを反転した新しい整数** を返せ。  

### 🔍 例
**例1**
Input: n = 43261596
Output: 964176192
説明:  
n = 00000010100101000001111010011100
result = 00111001011110000010100101000000

**例2**
Input: n = 2147483644
Output: 1073741822
説明:  
n = 01111111111111111111111111111100
result = 00111111111111111111111111111110

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- 32ビット整数を **右から1ビットずつ取り出す**。
- 取り出したビットを、結果の整数に **左から詰めていく**（ビットシフト）。
- 具体的には：
  1. 結果用の変数 `res = 0` を用意。
  2. 32回ループし、毎回 `n & 1` で最下位ビットを取り出す。
  3. `res` を左シフトしてから、そのビットを加える。
  4. `n` を右シフトして次のビットへ。
- 最後に `res` を返す。

### 🧠 ポイント
- ループは **必ず32回固定**（入力の長さに依存しない）。
- `& 1` で1ビットを取り出し、`<<` と `>>` でシフトするのが定石。
- Follow up の最適化:
  - 頻繁に呼ばれるなら、**キャッシュ（ビットごとに8bit単位で反転済み値を保存する）**を使うことで高速化できる。

## ⏱️ 計算量
- 時間計算量: **O(1)**（ループは32回固定）
- 空間計算量: **O(1)**

## 🧠 ポイントと学び
- ビット操作問題では **「1ビット抽出 → 結果に追加 → シフト」** の流れが基本。
- 32bit固定なので、必ず32回処理を回すことに注意。
- 最適化としては「キャッシュ」や「バイト単位での逆転」が実用的。

## 📈 提出結果
（参考値）
- Runtime: 14ms (Beats 79.85%)
- Memory: 12.55MB (Beats 7.52%)

---
