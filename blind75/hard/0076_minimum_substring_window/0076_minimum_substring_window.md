# 🧩 問題名: [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

## 📝 問題概要

文字列 `s` と `t` が与えられる。  
`s` の部分文字列のうち、**`t` のすべての文字（重複も含む）を含む最小の部分文字列**を求めよ。  
存在しない場合は空文字列 `""` を返す。

### 🔍 例
Input: s = "ADOBECODEBANC", t = "ABC"  
Output: "BANC"  
Explanation: "BANC" は 'A', 'B', 'C' をすべて含む最小の部分文字列。

Input: s = "a", t = "a"  
Output: "a"  

Input: s = "a", t = "aa"  
Output: "" （t の要求を満たせない）

---

## ✅ 解法方針（Approach）

### 💡 コアアイデア
- **スライディングウィンドウ + 2つのポインタ**を用いる。
- `t` の文字の出現回数をカウントしておき、`s` の中を左右のポインタで動かしながら「必要な文字が全部入ったか」を判定。
- 条件を満たしたら **左ポインタを縮めて最小化** を試みる。
- 最小長さを更新し続け、最終的な答えを返す。
- スライディングウィンドウの動きは、ミミズが動く様子に似ている

### 🔑 ステップ
1. `need = Counter(t)` を用意し、t の各文字の必要数を記録。  
2. `have` を動的に更新し、現在のウィンドウ内で何文字揃っているかを管理。  
3. `formed` が `len(need)` に到達したら「必要な文字をすべて含む」状態。  
4. その時点でウィンドウを縮め、最小長を更新。  
5. 最後に最小の部分文字列を返す。

---

## ⏱️ 計算量
- 時間計算量: **O(m + n)**  
  （左右ポインタは合計でそれぞれ1回ずつ進むため）  
- 空間計算量: **O(k)** （k = アルファベットの種類数、最大26または52）

---

## 🧠 ポイントと学び
- **「必要文字のカウント」+「現在のカウント」の二重管理**が重要。  
- 部分文字列を扱う問題では、**条件を満たしたら縮める**という発想が典型的。  
- O(m+n) の効率的解法は、スライディングウィンドウの定石。

---

## 📈 提出結果（参考）
- Runtime: 123ms (Beats 46.67%)  
- Memory: 12.64MB (Beats 75.58%)  

---