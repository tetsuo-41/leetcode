# 🧩 問題名: [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

## 📝 問題概要

k 個のソート済み連結リスト `lists` が与えられる。  
これらを **1つの昇順の連結リスト** にマージして返せ。  

### 🔍 例
Input: lists = [[1,4,5],[1,3,4],[2,6]]  
Output: [1,1,2,3,4,4,5,6]  


## ✅ 解法方針（Approach）

### 💡 コアアイデア
- k 本のソート済みリストをまとめて一つにする典型問題。
- 主な解法は以下の2つ：
  1. **逐次マージ**: 2本のリストをマージする関数を使って、1本ずつマージしていく。  
     → 時間計算量は O(k * n) 近くになる可能性あり。
  2. **優先度付きキュー（min-heap）**を使う:  
     - 各リストの先頭ノードをヒープに入れる。  
     - 最小のノードを取り出し、結果リストに追加し、そのノードの次をヒープに追加。  
     - これを繰り返すと効率的に昇順リストを構築できる。  

### 🧠 なぜヒープを使う？
- 各リストはソート済みなので、次に取るべき最小値は「各リストの先頭」のどれか。  
- この候補集合を管理するのにヒープを使えば、**取り出し O(log k)** で済む。  
- 全ノード数を `N` とすると、計算量は **O(N log k)**。

---

## ⏱️ 計算量
- 時間計算量: O(N log k)  
  - N = 全ノード数  
  - k = リストの本数
- 空間計算量: O(k)（ヒープに格納する要素）

---

## 🧠 ポイントと学び
- 「k本のソート済みリストをまとめる」= **多方向マージ**の典型。  
- 優先度付きキュー（heapq）の使い方を理解するのに最適な問題。  
- divide & conquer で 2本ずつマージしていく解法もある（O(N log k)）。  
    - 各ステップでリストをペアにしてマージ → 1本になるまで繰り返す。
    - マージソートの発想そのまま。
    - 実装はシンプルで、mergeTwoLists 関数を再利用できるのがメリット。
- 一旦すべてのノードをヒープに入れてからだと時間計算量がO(N log N)になってしまう（非効率）

---

## 📈 提出結果（例）
- Runtime: 92ms (Beats 78.45%)  
- Memory: 19.1MB (Beats 84.23%)  

